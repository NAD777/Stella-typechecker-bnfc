// Swift File generated by the BNF Converter (bnfc 2.9.6).

import Foundation
import Stella

func identityFn<A>(_ a: A) -> A { a }

func interpretStellaIdent(_ x: StellaIdentToken) -> String { x.value }
func interpretExtensionName(_ x: ExtensionNameToken) -> String { x.value }
func interpretMemoryAddress(_ x: MemoryAddressToken) -> String { x.value }
func interpretProgram(_ e: Program) -> String {
  switch (e) {
    case let .AProgram(languageDecl, extensionList, declList): "AProgram(\(interpretLanguageDecl(languageDecl)), \(extensionList.map(interpretExtension)), \(declList.map(interpretDecl)))"
  }
}

func interpretListStellaIdent(_ e: [StellaIdent]) -> String {
  "\(e)"
}

func interpretLanguageDecl(_ e: LanguageDecl) -> String {
  switch (e) {
    case let .LanguageCore(): "LanguageCore()"
  }
}

func interpretExtension(_ e: Extension) -> String {
  switch (e) {
    case let .AnExtension(extensionNameList): "AnExtension(\(extensionNameList.map(interpretExtensionName)))"
  }
}

func interpretListExtensionName(_ e: [ExtensionName]) -> String {
  "\(e)"
}

func interpretListExtension(_ e: [Extension]) -> String {
  "\(e)"
}

func interpretDecl(_ e: Decl) -> String {
  switch (e) {
    case let .DeclFun(annotationList, stellaIdent, paramDeclList, returnType, throwType, declList, expr): "DeclFun(\(annotationList.map(interpretAnnotation)), \(interpretStellaIdent(stellaIdent)), \(paramDeclList.map(interpretParamDecl)), \(interpretReturnType(returnType)), \(interpretThrowType(throwType)), \(declList.map(interpretDecl)), \(interpretExpr(expr)))"
    case let .DeclFunGeneric(annotationList, stellaIdent, stellaIdentList, paramDeclList, returnType, throwType, declList, expr): "DeclFunGeneric(\(annotationList.map(interpretAnnotation)), \(interpretStellaIdent(stellaIdent)), \(stellaIdentList.map(interpretStellaIdent)), \(paramDeclList.map(interpretParamDecl)), \(interpretReturnType(returnType)), \(interpretThrowType(throwType)), \(declList.map(interpretDecl)), \(interpretExpr(expr)))"
    case let .DeclTypeAlias(stellaIdent, stellaType): "DeclTypeAlias(\(interpretStellaIdent(stellaIdent)), \(interpretStellaType(stellaType)))"
    case let .DeclExceptionType(stellaType): "DeclExceptionType(\(interpretStellaType(stellaType)))"
    case let .DeclExceptionVariant(stellaIdent, stellaType): "DeclExceptionVariant(\(interpretStellaIdent(stellaIdent)), \(interpretStellaType(stellaType)))"
  }
}

func interpretListDecl(_ e: [Decl]) -> String {
  "\(e)"
}

func interpretLocalDecl(_ e: LocalDecl) -> String {
  switch (e) {
    case let .ALocalDecl(decl): "ALocalDecl(\(interpretDecl(decl)))"
  }
}

func interpretListLocalDecl(_ e: [LocalDecl]) -> String {
  "\(e)"
}

func interpretAnnotation(_ e: Annotation) -> String {
  switch (e) {
    case let .InlineAnnotation(): "InlineAnnotation()"
  }
}

func interpretListAnnotation(_ e: [Annotation]) -> String {
  "\(e)"
}

func interpretParamDecl(_ e: ParamDecl) -> String {
  switch (e) {
    case let .AParamDecl(stellaIdent, stellaType): "AParamDecl(\(interpretStellaIdent(stellaIdent)), \(interpretStellaType(stellaType)))"
  }
}

func interpretListParamDecl(_ e: [ParamDecl]) -> String {
  "\(e)"
}

func interpretReturnType(_ e: ReturnType) -> String {
  switch (e) {
    case let .NoReturnType(): "NoReturnType()"
    case let .SomeReturnType(stellaType): "SomeReturnType(\(interpretStellaType(stellaType)))"
  }
}

func interpretThrowType(_ e: ThrowType) -> String {
  switch (e) {
    case let .NoThrowType(): "NoThrowType()"
    case let .SomeThrowType(stellaTypeList): "SomeThrowType(\(stellaTypeList.map(interpretStellaType)))"
  }
}

func interpret`Type`(_ e: StellaType) -> String {
  switch (e) {
    case let .TypeFun(stellaTypeList, stellaType): "TypeFun(\(stellaTypeList.map(interpretStellaType)), \(interpretStellaType(stellaType)))"
    case let .TypeForAll(stellaIdentList, stellaType): "TypeForAll(\(stellaIdentList.map(interpretStellaIdent)), \(interpretStellaType(stellaType)))"
    case let .TypeRec(stellaIdent, stellaType): "TypeRec(\(interpretStellaIdent(stellaIdent)), \(interpretStellaType(stellaType)))"
    case let .TypeSum(stellaType1, stellaType2): "TypeSum(\(interpretStellaType(stellaType1)), \(interpretStellaType(stellaType2)))"
    case let .TypeTuple(stellaTypeList): "TypeTuple(\(stellaTypeList.map(interpretStellaType)))"
    case let .TypeRecord(recordFieldTypeList): "TypeRecord(\(recordFieldTypeList.map(interpretRecordFieldType)))"
    case let .TypeVariant(variantFieldTypeList): "TypeVariant(\(variantFieldTypeList.map(interpretVariantFieldType)))"
    case let .TypeList(stellaType): "TypeList(\(interpretStellaType(stellaType)))"
    case let .TypeBool(): "TypeBool()"
    case let .TypeNat(): "TypeNat()"
    case let .TypeUnit(): "TypeUnit()"
    case let .TypeTop(): "TypeTop()"
    case let .TypeBottom(): "TypeBottom()"
    case let .TypeRef(stellaType): "TypeRef(\(interpretStellaType(stellaType)))"
    case let .TypeVar(stellaIdent): "TypeVar(\(interpretStellaIdent(stellaIdent)))"
  }
}

func interpretListType(_ e: [StellaType]) -> String {
  "\(e)"
}

func interpretMatchCase(_ e: MatchCase) -> String {
  switch (e) {
    case let .AMatchCase(pattern, expr): "AMatchCase(\(interpretPattern(pattern)), \(interpretExpr(expr)))"
  }
}

func interpretListMatchCase(_ e: [MatchCase]) -> String {
  "\(e)"
}

func interpretOptionalTyping(_ e: OptionalTyping) -> String {
  switch (e) {
    case let .NoTyping(): "NoTyping()"
    case let .SomeTyping(stellaType): "SomeTyping(\(interpretStellaType(stellaType)))"
  }
}

func interpretPatternData(_ e: PatternData) -> String {
  switch (e) {
    case let .NoPatternData(): "NoPatternData()"
    case let .SomePatternData(pattern): "SomePatternData(\(interpretPattern(pattern)))"
  }
}

func interpretExprData(_ e: ExprData) -> String {
  switch (e) {
    case let .NoExprData(): "NoExprData()"
    case let .SomeExprData(expr): "SomeExprData(\(interpretExpr(expr)))"
  }
}

func interpretPattern(_ e: Pattern) -> String {
  switch (e) {
    case let .PatternVariant(stellaIdent, patternData): "PatternVariant(\(interpretStellaIdent(stellaIdent)), \(interpretPatternData(patternData)))"
    case let .PatternInl(pattern): "PatternInl(\(interpretPattern(pattern)))"
    case let .PatternInr(pattern): "PatternInr(\(interpretPattern(pattern)))"
    case let .PatternTuple(patternList): "PatternTuple(\(patternList.map(interpretPattern)))"
    case let .PatternRecord(labelledPatternList): "PatternRecord(\(labelledPatternList.map(interpretLabelledPattern)))"
    case let .PatternList(patternList): "PatternList(\(patternList.map(interpretPattern)))"
    case let .PatternCons(pattern1, pattern2): "PatternCons(\(interpretPattern(pattern1)), \(interpretPattern(pattern2)))"
    case let .PatternFalse(): "PatternFalse()"
    case let .PatternTrue(): "PatternTrue()"
    case let .PatternUnit(): "PatternUnit()"
    case let .PatternInt(integer): "PatternInt(\(identityFn(integer)))"
    case let .PatternSucc(pattern): "PatternSucc(\(interpretPattern(pattern)))"
    case let .PatternVar(stellaIdent): "PatternVar(\(interpretStellaIdent(stellaIdent)))"
  }
}

func interpretListPattern(_ e: [Pattern]) -> String {
  "\(e)"
}

func interpretLabelledPattern(_ e: LabelledPattern) -> String {
  switch (e) {
    case let .ALabelledPattern(stellaIdent, pattern): "ALabelledPattern(\(interpretStellaIdent(stellaIdent)), \(interpretPattern(pattern)))"
  }
}

func interpretListLabelledPattern(_ e: [LabelledPattern]) -> String {
  "\(e)"
}

func interpretBinding(_ e: Binding) -> String {
  switch (e) {
    case let .ABinding(stellaIdent, expr): "ABinding(\(interpretStellaIdent(stellaIdent)), \(interpretExpr(expr)))"
  }
}

func interpretListBinding(_ e: [Binding]) -> String {
  "\(e)"
}

func interpretExpr(_ e: Expr) -> String {
  switch (e) {
    case let .`Sequence`(expr1, expr2): "`Sequence`(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .Assign(expr1, expr2): "Assign(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .If(expr1, expr2, expr3): "If(\(interpretExpr(expr1)), \(interpretExpr(expr2)), \(interpretExpr(expr3)))"
    case let .Let(patternBindingList, expr): "Let(\(patternBindingList.map(interpretPatternBinding)), \(interpretExpr(expr)))"
    case let .LetRec(patternBindingList, expr): "LetRec(\(patternBindingList.map(interpretPatternBinding)), \(interpretExpr(expr)))"
    case let .TypeAbstraction(stellaIdentList, expr): "TypeAbstraction(\(stellaIdentList.map(interpretStellaIdent)), \(interpretExpr(expr)))"
    case let .LessThan(expr1, expr2): "LessThan(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .LessThanOrEqual(expr1, expr2): "LessThanOrEqual(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .GreaterThan(expr1, expr2): "GreaterThan(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .GreaterThanOrEqual(expr1, expr2): "GreaterThanOrEqual(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .Equal(expr1, expr2): "Equal(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .NotEqual(expr1, expr2): "NotEqual(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .TypeAsc(expr, stellaType): "TypeAsc(\(interpretExpr(expr)), \(interpretStellaType(stellaType)))"
    case let .TypeCast(expr, stellaType): "TypeCast(\(interpretExpr(expr)), \(interpretStellaType(stellaType)))"
    case let .Abstraction(paramDeclList, expr): "Abstraction(\(paramDeclList.map(interpretParamDecl)), \(interpretExpr(expr)))"
    case let .Variant(stellaIdent, exprData): "Variant(\(interpretStellaIdent(stellaIdent)), \(interpretExprData(exprData)))"
    case let .Match(expr, matchCaseList): "Match(\(interpretExpr(expr)), \(matchCaseList.map(interpretMatchCase)))"
    case let .List(exprList): "List(\(exprList.map(interpretExpr)))"
    case let .Add(expr1, expr2): "Add(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .Subtract(expr1, expr2): "Subtract(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .LogicOr(expr1, expr2): "LogicOr(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .Multiply(expr1, expr2): "Multiply(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .Divide(expr1, expr2): "Divide(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .LogicAnd(expr1, expr2): "LogicAnd(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .Ref(expr): "Ref(\(interpretExpr(expr)))"
    case let .Deref(expr): "Deref(\(interpretExpr(expr)))"
    case let .Application(expr, exprList): "Application(\(interpretExpr(expr)), \(exprList.map(interpretExpr)))"
    case let .TypeApplication(expr, stellaTypeList): "TypeApplication(\(interpretExpr(expr)), \(stellaTypeList.map(interpretStellaType)))"
    case let .DotRecord(expr, stellaIdent): "DotRecord(\(interpretExpr(expr)), \(interpretStellaIdent(stellaIdent)))"
    case let .DotTuple(expr, integer): "DotTuple(\(interpretExpr(expr)), \(identityFn(integer)))"
    case let .Tuple(exprList): "Tuple(\(exprList.map(interpretExpr)))"
    case let .Record(bindingList): "Record(\(bindingList.map(interpretBinding)))"
    case let .ConsList(expr1, expr2): "ConsList(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .Head(expr): "Head(\(interpretExpr(expr)))"
    case let .IsEmpty(expr): "IsEmpty(\(interpretExpr(expr)))"
    case let .Tail(expr): "Tail(\(interpretExpr(expr)))"
    case let .Panic(): "Panic()"
    case let .Throw(expr): "Throw(\(interpretExpr(expr)))"
    case let .TryCatch(expr1, pattern, expr2): "TryCatch(\(interpretExpr(expr1)), \(interpretPattern(pattern)), \(interpretExpr(expr2)))"
    case let .TryWith(expr1, expr2): "TryWith(\(interpretExpr(expr1)), \(interpretExpr(expr2)))"
    case let .Inl(expr): "Inl(\(interpretExpr(expr)))"
    case let .Inr(expr): "Inr(\(interpretExpr(expr)))"
    case let .Succ(expr): "Succ(\(interpretExpr(expr)))"
    case let .LogicNot(expr): "LogicNot(\(interpretExpr(expr)))"
    case let .Pred(expr): "Pred(\(interpretExpr(expr)))"
    case let .IsZero(expr): "IsZero(\(interpretExpr(expr)))"
    case let .Fix(expr): "Fix(\(interpretExpr(expr)))"
    case let .NatRec(expr1, expr2, expr3): "NatRec(\(interpretExpr(expr1)), \(interpretExpr(expr2)), \(interpretExpr(expr3)))"
    case let .Fold(stellaType, expr): "Fold(\(interpretStellaType(stellaType)), \(interpretExpr(expr)))"
    case let .Unfold(stellaType, expr): "Unfold(\(interpretStellaType(stellaType)), \(interpretExpr(expr)))"
    case let .ConstTrue(): "ConstTrue()"
    case let .ConstFalse(): "ConstFalse()"
    case let .ConstUnit(): "ConstUnit()"
    case let .ConstInt(integer): "ConstInt(\(identityFn(integer)))"
    case let .ConstDouble(stellaDouble): "ConstDouble(\(identityFn(stellaDouble)))"
    case let .ConstMemory(memoryAddress): "ConstMemory(\(interpretMemoryAddress(memoryAddress)))"
    case let .Var(stellaIdent): "Var(\(interpretStellaIdent(stellaIdent)))"
  }
}

func interpretListExpr(_ e: [Expr]) -> String {
  "\(e)"
}

func interpretPatternBinding(_ e: PatternBinding) -> String {
  switch (e) {
    case let .APatternBinding(pattern, expr): "APatternBinding(\(interpretPattern(pattern)), \(interpretExpr(expr)))"
  }
}

func interpretListPatternBinding(_ e: [PatternBinding]) -> String {
  "\(e)"
}

func interpretVariantFieldType(_ e: VariantFieldType) -> String {
  switch (e) {
    case let .AVariantFieldType(stellaIdent, optionalTyping): "AVariantFieldType(\(interpretStellaIdent(stellaIdent)), \(interpretOptionalTyping(optionalTyping)))"
  }
}

func interpretListVariantFieldType(_ e: [VariantFieldType]) -> String {
  "\(e)"
}

func interpretRecordFieldType(_ e: RecordFieldType) -> String {
  switch (e) {
    case let .ARecordFieldType(stellaIdent, stellaType): "ARecordFieldType(\(interpretStellaIdent(stellaIdent)), \(interpretStellaType(stellaType)))"
  }
}

func interpretListRecordFieldType(_ e: [RecordFieldType]) -> String {
  "\(e)"
}

func interpretTyping(_ e: Typing) -> String {
  switch (e) {
    case let .ATyping(expr, stellaType): "ATyping(\(interpretExpr(expr)), \(interpretStellaType(stellaType)))"
  }
}

