// Swift File generated by the BNF Converter (bnfc 2.9.6).

import Foundation

public struct DoubleToken: Hashable {
  public let value: Double
  public init(_ value: Double) {
    self.value = value
  }
}

public struct IntegerToken: Hashable {
  public let value: Int
  public init(_ value: Int) {
    self.value = value
  }
}

public struct StellaIdentToken: Hashable {
  public let value: String
  public init(_ value: String) {
    self.value = value
  }
}

public struct ExtensionNameToken: Hashable {
  public let value: String
  public init(_ value: String) {
    self.value = value
  }
}

public struct MemoryAddressToken: Hashable {
  public let value: String
  public init(_ value: String) {
    self.value = value
  }
}

public indirect enum Program: Hashable {
  case AProgram(LanguageDecl, [Extension_], [Decl])
}

public indirect enum LanguageDecl: Hashable {
  case LanguageCore
}

public indirect enum Extension_: Hashable {
  case AnExtension([ExtensionNameToken])
}

public indirect enum Decl: Hashable {
  case DeclFun([Annotation], StellaIdentToken, [ParamDecl], ReturnType, ThrowType, [Decl], Expr)
  case DeclFunGeneric([Annotation], StellaIdentToken, [StellaIdentToken], [ParamDecl], ReturnType, ThrowType, [Decl], Expr)
  case DeclTypeAlias(StellaIdentToken, Type_)
  case DeclExceptionType(Type_)
  case DeclExceptionVariant(StellaIdentToken, Type_)
}

public indirect enum LocalDecl: Hashable {
  case ALocalDecl(Decl)
}

public indirect enum Annotation: Hashable {
  case InlineAnnotation
}

public indirect enum ParamDecl: Hashable {
  case AParamDecl(StellaIdentToken, Type_)
}

public indirect enum ReturnType: Hashable {
  case NoReturnType
  case SomeReturnType(Type_)
}

public indirect enum ThrowType: Hashable {
  case NoThrowType
  case SomeThrowType([Type_])
}

public indirect enum Type_: Hashable {
  case TypeFun([Type_], Type_)
  case TypeForAll([StellaIdentToken], Type_)
  case TypeRec(StellaIdentToken, Type_)
  case TypeSum(Type_, Type_)
  case TypeTuple([Type_])
  case TypeRecord([RecordFieldType])
  case TypeVariant([VariantFieldType])
  case TypeList(Type_)
  case TypeBool
  case TypeNat
  case TypeUnit
  case TypeTop
  case TypeBottom
  case TypeRef(Type_)
  case TypeVar(StellaIdentToken)
}

public indirect enum MatchCase: Hashable {
  case AMatchCase(Pattern, Expr)
}

public indirect enum OptionalTyping: Hashable {
  case NoTyping
  case SomeTyping(Type_)
}

public indirect enum PatternData: Hashable {
  case NoPatternData
  case SomePatternData(Pattern)
}

public indirect enum ExprData: Hashable {
  case NoExprData
  case SomeExprData(Expr)
}

public indirect enum Pattern: Hashable {
  case PatternVariant(StellaIdentToken, PatternData)
  case PatternInl(Pattern)
  case PatternInr(Pattern)
  case PatternTuple([Pattern])
  case PatternRecord([LabelledPattern])
  case PatternList([Pattern])
  case PatternCons(Pattern, Pattern)
  case PatternFalse
  case PatternTrue
  case PatternUnit
  case PatternInt(IntegerToken)
  case PatternSucc(Pattern)
  case PatternVar(StellaIdentToken)
}

public indirect enum LabelledPattern: Hashable {
  case ALabelledPattern(StellaIdentToken, Pattern)
}

public indirect enum Binding: Hashable {
  case ABinding(StellaIdentToken, Expr)
}

public indirect enum Expr: Hashable {
  case `Sequence`(Expr, Expr?)
  case Assign(Expr, Expr)
  case If(Expr, Expr, Expr)
  case Let([PatternBinding], Expr)
  case LetRec([PatternBinding], Expr)
  case TypeAbstraction([StellaIdentToken], Expr)
  case LessThan(Expr, Expr)
  case LessThanOrEqual(Expr, Expr)
  case GreaterThan(Expr, Expr)
  case GreaterThanOrEqual(Expr, Expr)
  case Equal(Expr, Expr)
  case NotEqual(Expr, Expr)
  case TypeAsc(Expr, Type_)
  case TypeCast(Expr, Type_)
  case Abstraction([ParamDecl], Expr)
  case Variant(StellaIdentToken, ExprData)
  case Match(Expr, [MatchCase])
  case List([Expr])
  case Add(Expr, Expr)
  case Subtract(Expr, Expr)
  case LogicOr(Expr, Expr)
  case Multiply(Expr, Expr)
  case Divide(Expr, Expr)
  case LogicAnd(Expr, Expr)
  case Ref(Expr)
  case Deref(Expr)
  case Application(Expr, [Expr])
  case TypeApplication(Expr, [Type_])
  case DotRecord(Expr, StellaIdentToken)
  case DotTuple(Expr, IntegerToken)
  case Tuple([Expr])
  case Record([Binding])
  case ConsList(Expr, Expr)
  case Head(Expr)
  case IsEmpty(Expr)
  case Tail(Expr)
  case Panic
  case Throw(Expr)
  case TryCatch(Expr, Pattern, Expr)
  case TryWith(Expr, Expr)
  case Inl(Expr)
  case Inr(Expr)
  case Succ(Expr)
  case LogicNot(Expr)
  case Pred(Expr)
  case IsZero(Expr)
  case Fix(Expr)
  case NatRec(Expr, Expr, Expr)
  case Fold(Type_, Expr)
  case Unfold(Type_, Expr)
  case ConstTrue
  case ConstFalse
  case ConstUnit
  case ConstInt(IntegerToken)
  case ConstDouble(DoubleToken)
  case ConstMemory(MemoryAddressToken)
  case Var(StellaIdentToken)
}

public indirect enum PatternBinding: Hashable {
  case APatternBinding(Pattern, Expr)
}

public indirect enum VariantFieldType: Hashable {
  case AVariantFieldType(StellaIdentToken, OptionalTyping)
}

public indirect enum RecordFieldType: Hashable {
  case ARecordFieldType(StellaIdentToken, Type_)
}

public indirect enum Typing: Hashable {
  case ATyping(Expr, Type_)
}
