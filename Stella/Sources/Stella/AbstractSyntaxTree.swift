// Swift File generated by the BNF Converter (bnfc 2.9.6).

import Foundation

public struct DoubleToken: Hashable {
  public let value: Double
  public init(_ value: Double) {
    self.value = value
  }
}

public struct IntegerToken: Hashable {
  public let value: Int
  public init(_ value: Int) {
    self.value = value
  }
}

public struct StellaIdentToken: Hashable {
  public let value: String
  public init(_ value: String) {
    self.value = value
  }
}

public struct ExtensionNameToken: Hashable {
  public let value: String
  public init(_ value: String) {
    self.value = value
  }
}

public struct MemoryAddressToken: Hashable {
  public let value: String
  public init(_ value: String) {
    self.value = value
  }
}

public indirect enum Program: Hashable {
  case aProgram(LanguageDecl, [Extension_], [Decl])
}

public indirect enum LanguageDecl: Hashable {
  case languageCore
}

public indirect enum Extension_: Hashable {
  case anExtension([ExtensionNameToken])
}

public indirect enum Decl: Hashable {
  case declFun([Annotation], StellaIdentToken, [ParamDecl], ReturnType, ThrowType, [Decl], Expr)
  case declFunGeneric([Annotation], StellaIdentToken, [StellaIdentToken], [ParamDecl], ReturnType, ThrowType, [Decl], Expr)
  case declTypeAlias(StellaIdentToken, Type_)
  case declExceptionType(Type_)
  case declExceptionVariant(StellaIdentToken, Type_)
}

public indirect enum LocalDecl: Hashable {
  case aLocalDecl(Decl)
}

public indirect enum Annotation: Hashable {
  case inlineAnnotation
}

public indirect enum ParamDecl: Hashable {
  case aParamDecl(StellaIdentToken, Type_)
}

public indirect enum ReturnType: Hashable {
  case noReturnType
  case someReturnType(Type_)
}

public indirect enum ThrowType: Hashable {
  case noThrowType
  case someThrowType([Type_])
}

public indirect enum Type_: Hashable {
  case typeFun([Type_], Type_)
  case typeForAll([StellaIdentToken], Type_)
  case typeRec(StellaIdentToken, Type_)
  case typeSum(Type_, Type_)
  case typeTuple([Type_])
  case typeRecord([RecordFieldType])
  case typeVariant([VariantFieldType])
  case typeList(Type_)
  case typeBool
  case typeNat
  case typeUnit
  case typeTop
  case typeBottom
  case typeRef(Type_)
  case typeVar(StellaIdentToken)
}

public indirect enum MatchCase: Hashable {
  case aMatchCase(Pattern, Expr)
}

public indirect enum OptionalTyping: Hashable {
  case noTyping
  case someTyping(Type_)
}

public indirect enum PatternData: Hashable {
  case noPatternData
  case somePatternData(Pattern)
}

public indirect enum ExprData: Hashable {
  case noExprData
  case someExprData(Expr)
}

public indirect enum Pattern: Hashable {
  case patternVariant(StellaIdentToken, PatternData)
  case patternInl(Pattern)
  case patternInr(Pattern)
  case patternTuple([Pattern])
  case patternRecord([LabelledPattern])
  case patternList([Pattern])
  case patternCons(Pattern, Pattern)
  case patternFalse
  case patternTrue
  case patternUnit
  case patternInt(IntegerToken)
  case patternSucc(Pattern)
  case patternVar(StellaIdentToken)
}

public indirect enum LabelledPattern: Hashable {
  case aLabelledPattern(StellaIdentToken, Pattern)
}

public indirect enum Binding: Hashable {
  case aBinding(StellaIdentToken, Expr)
}

public indirect enum Expr: Hashable {
  case sequence(Expr, Expr?)
  case assign(Expr, Expr)
  case `if`(Expr, Expr, Expr)
  case `let`([PatternBinding], Expr)
  case letRec([PatternBinding], Expr)
  case typeAbstraction([StellaIdentToken], Expr)
  case lessThan(Expr, Expr)
  case lessThanOrEqual(Expr, Expr)
  case greaterThan(Expr, Expr)
  case greaterThanOrEqual(Expr, Expr)
  case equal(Expr, Expr)
  case notEqual(Expr, Expr)
  case typeAsc(Expr, Type_)
  case typeCast(Expr, Type_)
  case abstraction([ParamDecl], Expr)
  case variant(StellaIdentToken, ExprData)
  case match(Expr, [MatchCase])
  case list([Expr])
  case add(Expr, Expr)
  case subtract(Expr, Expr)
  case logicOr(Expr, Expr)
  case multiply(Expr, Expr)
  case divide(Expr, Expr)
  case logicAnd(Expr, Expr)
  case ref(Expr)
  case deref(Expr)
  case application(Expr, [Expr])
  case typeApplication(Expr, [Type_])
  case dotRecord(Expr, StellaIdentToken)
  case dotTuple(Expr, IntegerToken)
  case tuple([Expr])
  case record([Binding])
  case consList(Expr, Expr)
  case head(Expr)
  case isEmpty(Expr)
  case tail(Expr)
  case panic
  case `throw`(Expr)
  case tryCatch(Expr, Pattern, Expr)
  case tryWith(Expr, Expr)
  case inl(Expr)
  case inr(Expr)
  case succ(Expr)
  case logicNot(Expr)
  case pred(Expr)
  case isZero(Expr)
  case fix(Expr)
  case natRec(Expr, Expr, Expr)
  case fold(Type_, Expr)
  case unfold(Type_, Expr)
  case constTrue
  case constFalse
  case constUnit
  case constInt(IntegerToken)
  case constDouble(DoubleToken)
  case constMemory(MemoryAddressToken)
  case `var`(StellaIdentToken)
}

public indirect enum PatternBinding: Hashable {
  case aPatternBinding(Pattern, Expr)
}

public indirect enum VariantFieldType: Hashable {
  case aVariantFieldType(StellaIdentToken, OptionalTyping)
}

public indirect enum RecordFieldType: Hashable {
  case aRecordFieldType(StellaIdentToken, Type_)
}

public indirect enum Typing: Hashable {
  case aTyping(Expr, Type_)
}
