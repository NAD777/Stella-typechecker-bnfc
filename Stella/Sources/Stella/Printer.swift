// Swift File generated by the BNF Converter (bnfc 2.9.6).

final class Rendered {
  private enum Token {
    case text(value: String)
    case newline(indentShift: Int)
    case space

    func toString() -> String {
      switch self {
        case .text(let value):
          return value
        case .newline:
          return "\n"
        case .space:
          return " "
      }
    }
  }

  static let shared = Rendered()
  private let indentSize = 2
  private init() {}
  func render(_ tokens: [String]) -> String {
    let transformedTokens = transform(tokens)
    let groupedTokens = groupTokens(transformedTokens)
    return groupedTokens
      .map { addIndentation(to: $0) }
      .map { $0.map { $0.toString() }.joined() }
      .joined(separator: "\n")
  }

  private func transform(_ tokens: [String]) -> [Token] {
    var result: [Token] = []
    var insideBrackets = false
    for token in tokens {
      switch token {
        case "", " ":
          if insideBrackets {
            continue
          }
        case "{":
          result.append(.text(value: token))
          result.append(.newline(indentShift: 1))
        case "}":
          dropTrailingNewlines(from: &result)
          result.append(.newline(indentShift: -1))
          result.append(.text(value: token))
          result.append(.newline(indentShift: 0))
        case "[":
          dropTrailingSpaces(from: &result)
          result.append(.space)
          result.append(.text(value: token))
          insideBrackets = true
        case "]":
          dropTrailingSpaces(from: &result)
          result.append(.text(value: token))
          insideBrackets = false
          result.append(.space)
        case "(", ")", "<", ">", ",", ".":
          dropTrailingSpaces(from: &result)
          if token == ")" || token == "]" || token == "}" {
            dropTrailingNewlines(from: &result)
          }
          result.append(.text(value: token))
          if token != "." && token != "(" && !insideBrackets {
            result.append(.space)
          }
        case ";":
          dropTrailingSpaces(from: &result)
          dropTrailingNewlines(from: &result)
          result.append(.text(value: token))
          result.append(.newline(indentShift: 0))
        case "return":
          result.append(.text(value: token))
          result.append(.space)
        default:
          result.append(.text(value: token))
          if !insideBrackets {
            result.append(.space)
          }
      }
    }
    dropTrailingSpaces(from: &result)
    dropTrailingNewlines(from: &result)
    return result
  }

  private func groupTokens(_ tokens: [Token]) -> [(indentationLevel: Int, tokens: [Token])] {
    var groups: [(indentationLevel: Int, tokens: [Token])] = []
    var currentIndentation = 0
    for token in tokens {
      if case .newline(let shift) = token {
        currentIndentation += shift
        groups.append((currentIndentation, []))
      } else {
        if groups.isEmpty {
          groups.append((currentIndentation, []))
        }
        groups[groups.count - 1].tokens.append(token)
      }
    }
    return groups
  }

  private func addIndentation(to group: (indentationLevel: Int, tokens: [Token])) -> [Token] {
    var tokens = group.tokens
    if group.indentationLevel > 0 {
      tokens.insert(.text(value: String(repeating: " ", count: indentSize * group.indentationLevel)), at: 0)
    }
    return tokens
  }

  private func dropTrailingSpaces(from tokens: inout [Token]) {
    while let last = tokens.last, case .space = last {
      tokens.removeLast()
    }
  }

  private func dropTrailingNewlines(from tokens: inout [Token]) {
    while let last = tokens.last, case .newline = last {
      tokens.removeLast()
    }
  }
}

extension DoubleToken {
  public var printed: String {
    String(value)
  }
}

extension IntegerToken {
  public var printed: String {
    String(value)
  }
}

extension StellaIdentToken {
  public var printed: String {
    String(value)
  }
}

extension ExtensionNameToken {
  public var printed: String {
    String(value)
  }
}

extension MemoryAddressToken {
  public var printed: String {
    String(value)
  }
}

extension Program {
  public var printProgram: String {
    Rendered.shared.render(prettifyProgram(self))
  }
}

extension [StellaIdentToken] {
  public var printListOfStellaIdent: String {
    Rendered.shared.render(prettifyListOfStellaIdent(self))
  }
}

extension LanguageDecl {
  public var printLanguageDecl: String {
    Rendered.shared.render(prettifyLanguageDecl(self))
  }
}

extension Extension_ {
  public var printExtension: String {
    Rendered.shared.render(prettifyExtension(self))
  }
}

extension [ExtensionNameToken] {
  public var printListOfExtensionName: String {
    Rendered.shared.render(prettifyListOfExtensionName(self))
  }
}

extension [Extension_] {
  public var printListOfExtension: String {
    Rendered.shared.render(prettifyListOfExtension(self))
  }
}

extension Decl {
  public var printDecl: String {
    Rendered.shared.render(prettifyDecl(self))
  }
}

extension [Decl] {
  public var printListOfDecl: String {
    Rendered.shared.render(prettifyListOfDecl(self))
  }
}

extension LocalDecl {
  public var printLocalDecl: String {
    Rendered.shared.render(prettifyLocalDecl(self))
  }
}

extension [LocalDecl] {
  public var printListOfLocalDecl: String {
    Rendered.shared.render(prettifyListOfLocalDecl(self))
  }
}

extension Annotation {
  public var printAnnotation: String {
    Rendered.shared.render(prettifyAnnotation(self))
  }
}

extension [Annotation] {
  public var printListOfAnnotation: String {
    Rendered.shared.render(prettifyListOfAnnotation(self))
  }
}

extension ParamDecl {
  public var printParamDecl: String {
    Rendered.shared.render(prettifyParamDecl(self))
  }
}

extension [ParamDecl] {
  public var printListOfParamDecl: String {
    Rendered.shared.render(prettifyListOfParamDecl(self))
  }
}

extension ReturnType {
  public var printReturnType: String {
    Rendered.shared.render(prettifyReturnType(self))
  }
}

extension ThrowType {
  public var printThrowType: String {
    Rendered.shared.render(prettifyThrowType(self))
  }
}

extension [Type_] {
  public var printListOfType9: String {
    Rendered.shared.render(prettifyListOfType9(self))
  }
}

extension MatchCase {
  public var printMatchCase: String {
    Rendered.shared.render(prettifyMatchCase(self))
  }
}

extension [MatchCase] {
  public var printListOfMatchCase: String {
    Rendered.shared.render(prettifyListOfMatchCase(self))
  }
}

extension OptionalTyping {
  public var printOptionalTyping: String {
    Rendered.shared.render(prettifyOptionalTyping(self))
  }
}

extension PatternData {
  public var printPatternData: String {
    Rendered.shared.render(prettifyPatternData(self))
  }
}

extension ExprData {
  public var printExprData: String {
    Rendered.shared.render(prettifyExprData(self))
  }
}

extension Pattern {
  public var printPattern: String {
    Rendered.shared.render(prettifyPattern(self))
  }
}

extension [Pattern] {
  public var printListOfPattern: String {
    Rendered.shared.render(prettifyListOfPattern(self))
  }
}

extension LabelledPattern {
  public var printLabelledPattern: String {
    Rendered.shared.render(prettifyLabelledPattern(self))
  }
}

extension [LabelledPattern] {
  public var printListOfLabelledPattern: String {
    Rendered.shared.render(prettifyListOfLabelledPattern(self))
  }
}

extension Binding {
  public var printBinding: String {
    Rendered.shared.render(prettifyBinding(self))
  }
}

extension [Binding] {
  public var printListOfBinding: String {
    Rendered.shared.render(prettifyListOfBinding(self))
  }
}

extension Expr {
  public var printExpr: String {
    Rendered.shared.render(prettifyExpr(self))
  }
}

extension [Expr] {
  public var printListOfExpr: String {
    Rendered.shared.render(prettifyListOfExpr(self))
  }
}

extension PatternBinding {
  public var printPatternBinding: String {
    Rendered.shared.render(prettifyPatternBinding(self))
  }
}

extension [PatternBinding] {
  public var printListOfPatternBinding: String {
    Rendered.shared.render(prettifyListOfPatternBinding(self))
  }
}

extension [Expr] {
  public var printListOfExpr2: String {
    Rendered.shared.render(prettifyListOfExpr2(self))
  }
}

extension Type_ {
  public var printType: String {
    Rendered.shared.render(prettifyType(self))
  }
}

extension [Type_] {
  public var printListOfType: String {
    Rendered.shared.render(prettifyListOfType(self))
  }
}

extension VariantFieldType {
  public var printVariantFieldType: String {
    Rendered.shared.render(prettifyVariantFieldType(self))
  }
}

extension [VariantFieldType] {
  public var printListOfVariantFieldType: String {
    Rendered.shared.render(prettifyListOfVariantFieldType(self))
  }
}

extension RecordFieldType {
  public var printRecordFieldType: String {
    Rendered.shared.render(prettifyRecordFieldType(self))
  }
}

extension [RecordFieldType] {
  public var printListOfRecordFieldType: String {
    Rendered.shared.render(prettifyListOfRecordFieldType(self))
  }
}

extension Typing {
  public var printTyping: String {
    Rendered.shared.render(prettifyTyping(self))
  }
}

func prettifyProgram(_ node: Program) -> [String] {
  switch node {
    case let .AProgram(languagedecl, listextension, listdecl):
      var result = [String]()
      result += prettifyLanguageDecl(languagedecl)
      result += prettifyListOfExtension(listextension)
      result += prettifyListOfDecl(listdecl)
      return result
  }
}

func prettifyListOfStellaIdent(_ list: [StellaIdentToken]) -> [String] {
  list.flatMap { item in [item.printed] + [","] }.dropLast()
}

func prettifyLanguageDecl(_ node: LanguageDecl) -> [String] {
  switch node {
    case .LanguageCore:
      var result = [String]()
      result += ["language"]
      result += ["core"]
      result += [";"]
      return result
  }
}

func prettifyExtension(_ node: Extension_) -> [String] {
  switch node {
    case let .AnExtension(listextensionname):
      var result = [String]()
      result += ["extend"]
      result += ["with"]
      result += prettifyListOfExtensionName(listextensionname)
      return result
  }
}

func prettifyListOfExtensionName(_ list: [ExtensionNameToken]) -> [String] {
  list.flatMap { item in [item.printed] + [","] }.dropLast()
}

func prettifyListOfExtension(_ list: [Extension_]) -> [String] {
  list.flatMap { item in prettifyExtension(item) + [";"] }
}

func prettifyDecl(_ node: Decl) -> [String] {
  switch node {
    case let .DeclFun(listannotation, stellaident, listparamdecl, returntype, throwtype, listdecl, expr):
      var result = [String]()
      result += prettifyListOfAnnotation(listannotation)
      result += ["fn"]
      result += [stellaident.printed]
      result += ["("]
      result += prettifyListOfParamDecl(listparamdecl)
      result += [")"]
      result += prettifyReturnType(returntype)
      result += prettifyThrowType(throwtype)
      result += ["{"]
      result += prettifyListOfDecl(listdecl)
      result += ["return"]
      result += prettifyExpr(expr)
      result += ["}"]
      return result
    case let .DeclFunGeneric(listannotation, stellaident, liststellaident, listparamdecl, returntype, throwtype, listdecl, expr):
      var result = [String]()
      result += prettifyListOfAnnotation(listannotation)
      result += ["generic"]
      result += ["fn"]
      result += [stellaident.printed]
      result += ["["]
      result += prettifyListOfStellaIdent(liststellaident)
      result += ["]"]
      result += ["("]
      result += prettifyListOfParamDecl(listparamdecl)
      result += [")"]
      result += prettifyReturnType(returntype)
      result += prettifyThrowType(throwtype)
      result += ["{"]
      result += prettifyListOfDecl(listdecl)
      result += ["return"]
      result += prettifyExpr(expr)
      result += ["}"]
      return result
    case let .DeclTypeAlias(stellaident, type_):
      var result = [String]()
      result += ["type"]
      result += [stellaident.printed]
      result += ["="]
      result += prettifyType(type_)
      return result
    case let .DeclExceptionType(type_):
      var result = [String]()
      result += ["exception"]
      result += ["type"]
      result += ["="]
      result += prettifyType(type_)
      return result
    case let .DeclExceptionVariant(stellaident, type_):
      var result = [String]()
      result += ["exception"]
      result += ["variant"]
      result += [stellaident.printed]
      result += [":"]
      result += prettifyType(type_)
      return result
  }
}

func prettifyListOfDecl(_ list: [Decl]) -> [String] {
  list.flatMap { item in prettifyDecl(item) + [""] }.dropLast()
}

func prettifyLocalDecl(_ node: LocalDecl) -> [String] {
  switch node {
    case let .ALocalDecl(decl):
      var result = [String]()
      result += prettifyDecl(decl)
      return result
  }
}

func prettifyListOfLocalDecl(_ list: [LocalDecl]) -> [String] {
  list.flatMap { item in prettifyLocalDecl(item) + [";"] }
}

func prettifyAnnotation(_ node: Annotation) -> [String] {
  switch node {
    case .InlineAnnotation:
      var result = [String]()
      result += ["inline"]
      return result
  }
}

func prettifyListOfAnnotation(_ list: [Annotation]) -> [String] {
  list.flatMap { item in prettifyAnnotation(item) + [""] }.dropLast()
}

func prettifyParamDecl(_ node: ParamDecl) -> [String] {
  switch node {
    case let .AParamDecl(stellaident, type_):
      var result = [String]()
      result += [stellaident.printed]
      result += [":"]
      result += prettifyType(type_)
      return result
  }
}

func prettifyListOfParamDecl(_ list: [ParamDecl]) -> [String] {
  list.flatMap { item in prettifyParamDecl(item) + [","] }.dropLast()
}

func prettifyReturnType(_ node: ReturnType) -> [String] {
  switch node {
    case .NoReturnType:
      var result = [String]()

      return result
    case let .SomeReturnType(type_):
      var result = [String]()
      result += ["->"]
      result += prettifyType(type_)
      return result
  }
}

func prettifyThrowType(_ node: ThrowType) -> [String] {
  switch node {
    case .NoThrowType:
      var result = [String]()

      return result
    case let .SomeThrowType(listtype):
      var result = [String]()
      result += ["throws"]
      result += prettifyListOfType9(listtype)
      return result
  }
}

func prettifyListOfType9(_ list: [Type_]) -> [String] {
  list.flatMap { item in prettifyType(item) + [","] }.dropLast()
}

func prettifyMatchCase(_ node: MatchCase) -> [String] {
  switch node {
    case let .AMatchCase(pattern, expr):
      var result = [String]()
      result += prettifyPattern(pattern)
      result += ["=>"]
      result += prettifyExpr(expr)
      return result
  }
}

func prettifyListOfMatchCase(_ list: [MatchCase]) -> [String] {
  list.flatMap { item in prettifyMatchCase(item) + ["|"] }.dropLast()
}

func prettifyOptionalTyping(_ node: OptionalTyping) -> [String] {
  switch node {
    case .NoTyping:
      var result = [String]()

      return result
    case let .SomeTyping(type_):
      var result = [String]()
      result += [":"]
      result += prettifyType(type_)
      return result
  }
}

func prettifyPatternData(_ node: PatternData) -> [String] {
  switch node {
    case .NoPatternData:
      var result = [String]()

      return result
    case let .SomePatternData(pattern):
      var result = [String]()
      result += ["="]
      result += prettifyPattern(pattern)
      return result
  }
}

func prettifyExprData(_ node: ExprData) -> [String] {
  switch node {
    case .NoExprData:
      var result = [String]()

      return result
    case let .SomeExprData(expr):
      var result = [String]()
      result += ["="]
      result += prettifyExpr(expr)
      return result
  }
}

func prettifyPattern(_ node: Pattern) -> [String] {
  switch node {
    case let .PatternVariant(stellaident, patterndata):
      var result = [String]()
      result += ["<|"]
      result += [stellaident.printed]
      result += prettifyPatternData(patterndata)
      result += ["|>"]
      return result
    case let .PatternInl(pattern):
      var result = [String]()
      result += ["inl"]
      result += ["("]
      result += prettifyPattern(pattern)
      result += [")"]
      return result
    case let .PatternInr(pattern):
      var result = [String]()
      result += ["inr"]
      result += ["("]
      result += prettifyPattern(pattern)
      result += [")"]
      return result
    case let .PatternTuple(listpattern):
      var result = [String]()
      result += ["{"]
      result += prettifyListOfPattern(listpattern)
      result += ["}"]
      return result
    case let .PatternRecord(listlabelledpattern):
      var result = [String]()
      result += ["{"]
      result += prettifyListOfLabelledPattern(listlabelledpattern)
      result += ["}"]
      return result
    case let .PatternList(listpattern):
      var result = [String]()
      result += ["["]
      result += prettifyListOfPattern(listpattern)
      result += ["]"]
      return result
    case let .PatternCons(pattern1, pattern2):
      var result = [String]()
      result += ["("]
      result += prettifyPattern(pattern1)
      result += [","]
      result += prettifyPattern(pattern2)
      result += [")"]
      return result
    case .PatternFalse:
      var result = [String]()
      result += ["false"]
      return result
    case .PatternTrue:
      var result = [String]()
      result += ["true"]
      return result
    case .PatternUnit:
      var result = [String]()
      result += ["unit"]
      return result
    case let .PatternInt(integer):
      var result = [String]()
      result += [integer.printed]
      return result
    case let .PatternSucc(pattern):
      var result = [String]()
      result += ["succ"]
      result += ["("]
      result += prettifyPattern(pattern)
      result += [")"]
      return result
    case let .PatternVar(stellaident):
      var result = [String]()
      result += [stellaident.printed]
      return result
  }
}

func prettifyListOfPattern(_ list: [Pattern]) -> [String] {
  list.flatMap { item in prettifyPattern(item) + [","] }.dropLast()
}

func prettifyLabelledPattern(_ node: LabelledPattern) -> [String] {
  switch node {
    case let .ALabelledPattern(stellaident, pattern):
      var result = [String]()
      result += [stellaident.printed]
      result += ["="]
      result += prettifyPattern(pattern)
      return result
  }
}

func prettifyListOfLabelledPattern(_ list: [LabelledPattern]) -> [String] {
  list.flatMap { item in prettifyLabelledPattern(item) + [","] }.dropLast()
}

func prettifyBinding(_ node: Binding) -> [String] {
  switch node {
    case let .ABinding(stellaident, expr):
      var result = [String]()
      result += [stellaident.printed]
      result += ["="]
      result += prettifyExpr(expr)
      return result
  }
}

func prettifyListOfBinding(_ list: [Binding]) -> [String] {
  list.flatMap { item in prettifyBinding(item) + [","] }.dropLast()
}

func prettifyExpr(_ node: Expr) -> [String] {
  switch node {
    case let .Sequence(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += [";"]
      result += (expr2.map { prettifyExpr($0) }) ?? []
      return result
    case let .Assign(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += [":="]
      result += prettifyExpr(expr2)
      return result
    case let .If(expr1, expr2, expr3):
      var result = [String]()
      result += ["if"]
      result += prettifyExpr(expr1)
      result += ["then"]
      result += prettifyExpr(expr2)
      result += ["else"]
      result += prettifyExpr(expr3)
      return result
    case let .Let(listpatternbinding, expr):
      var result = [String]()
      result += ["let"]
      result += prettifyListOfPatternBinding(listpatternbinding)
      result += ["in"]
      result += prettifyExpr(expr)
      return result
    case let .LetRec(listpatternbinding, expr):
      var result = [String]()
      result += ["letrec"]
      result += prettifyListOfPatternBinding(listpatternbinding)
      result += ["in"]
      result += prettifyExpr(expr)
      return result
    case let .TypeAbstraction(liststellaident, expr):
      var result = [String]()
      result += ["generic"]
      result += ["["]
      result += prettifyListOfStellaIdent(liststellaident)
      result += ["]"]
      result += prettifyExpr(expr)
      return result
    case let .LessThan(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["<"]
      result += prettifyExpr(expr2)
      return result
    case let .LessThanOrEqual(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["<="]
      result += prettifyExpr(expr2)
      return result
    case let .GreaterThan(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += [">"]
      result += prettifyExpr(expr2)
      return result
    case let .GreaterThanOrEqual(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += [">="]
      result += prettifyExpr(expr2)
      return result
    case let .Equal(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["=="]
      result += prettifyExpr(expr2)
      return result
    case let .NotEqual(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["!="]
      result += prettifyExpr(expr2)
      return result
    case let .TypeAsc(expr, type_):
      var result = [String]()
      result += prettifyExpr(expr)
      result += ["as"]
      result += prettifyType(type_)
      return result
    case let .TypeCast(expr, type_):
      var result = [String]()
      result += prettifyExpr(expr)
      result += ["cast"]
      result += ["as"]
      result += prettifyType(type_)
      return result
    case let .Abstraction(listparamdecl, expr):
      var result = [String]()
      result += ["fn"]
      result += ["("]
      result += prettifyListOfParamDecl(listparamdecl)
      result += [")"]
      result += ["{"]
      result += ["return"]
      result += prettifyExpr(expr)
      result += ["}"]
      return result
    case let .Variant(stellaident, exprdata):
      var result = [String]()
      result += ["<|"]
      result += [stellaident.printed]
      result += prettifyExprData(exprdata)
      result += ["|>"]
      return result
    case let .Match(expr, listmatchcase):
      var result = [String]()
      result += ["match"]
      result += prettifyExpr(expr)
      result += ["{"]
      result += prettifyListOfMatchCase(listmatchcase)
      result += ["}"]
      return result
    case let .List(listexpr):
      var result = [String]()
      result += ["["]
      result += prettifyListOfExpr(listexpr)
      result += ["]"]
      return result
    case let .Add(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["+"]
      result += prettifyExpr(expr2)
      return result
    case let .Subtract(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["-"]
      result += prettifyExpr(expr2)
      return result
    case let .LogicOr(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["or"]
      result += prettifyExpr(expr2)
      return result
    case let .Multiply(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["*"]
      result += prettifyExpr(expr2)
      return result
    case let .Divide(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["/"]
      result += prettifyExpr(expr2)
      return result
    case let .LogicAnd(expr1, expr2):
      var result = [String]()
      result += prettifyExpr(expr1)
      result += ["and"]
      result += prettifyExpr(expr2)
      return result
    case let .Ref(expr):
      var result = [String]()
      result += ["new"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .Deref(expr):
      var result = [String]()
      result += ["*"]
      result += prettifyExpr(expr)
      return result
    case let .Application(expr, listexpr):
      var result = [String]()
      result += prettifyExpr(expr)
      result += ["("]
      result += prettifyListOfExpr(listexpr)
      result += [")"]
      return result
    case let .TypeApplication(expr, listtype):
      var result = [String]()
      result += prettifyExpr(expr)
      result += ["["]
      result += prettifyListOfType(listtype)
      result += ["]"]
      return result
    case let .DotRecord(expr, stellaident):
      var result = [String]()
      result += prettifyExpr(expr)
      result += ["."]
      result += [stellaident.printed]
      return result
    case let .DotTuple(expr, integer):
      var result = [String]()
      result += prettifyExpr(expr)
      result += ["."]
      result += [integer.printed]
      return result
    case let .Tuple(listexpr):
      var result = [String]()
      result += ["{"]
      result += prettifyListOfExpr(listexpr)
      result += ["}"]
      return result
    case let .Record(listbinding):
      var result = [String]()
      result += ["{"]
      result += prettifyListOfBinding(listbinding)
      result += ["}"]
      return result
    case let .ConsList(expr1, expr2):
      var result = [String]()
      result += ["cons"]
      result += ["("]
      result += prettifyExpr(expr1)
      result += [","]
      result += prettifyExpr(expr2)
      result += [")"]
      return result
    case let .Head(expr):
      var result = [String]()
      result += ["List::head"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .IsEmpty(expr):
      var result = [String]()
      result += ["List::isempty"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .Tail(expr):
      var result = [String]()
      result += ["List::tail"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case .Panic:
      var result = [String]()
      result += ["panic!"]
      return result
    case let .Throw(expr):
      var result = [String]()
      result += ["throw"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .TryCatch(expr1, pattern, expr2):
      var result = [String]()
      result += ["try"]
      result += ["{"]
      result += prettifyExpr(expr1)
      result += ["}"]
      result += ["catch"]
      result += ["{"]
      result += prettifyPattern(pattern)
      result += ["=>"]
      result += prettifyExpr(expr2)
      result += ["}"]
      return result
    case let .TryWith(expr1, expr2):
      var result = [String]()
      result += ["try"]
      result += ["{"]
      result += prettifyExpr(expr1)
      result += ["}"]
      result += ["with"]
      result += ["{"]
      result += prettifyExpr(expr2)
      result += ["}"]
      return result
    case let .Inl(expr):
      var result = [String]()
      result += ["inl"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .Inr(expr):
      var result = [String]()
      result += ["inr"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .Succ(expr):
      var result = [String]()
      result += ["succ"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .LogicNot(expr):
      var result = [String]()
      result += ["not"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .Pred(expr):
      var result = [String]()
      result += ["Nat::pred"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .IsZero(expr):
      var result = [String]()
      result += ["Nat::iszero"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .Fix(expr):
      var result = [String]()
      result += ["fix"]
      result += ["("]
      result += prettifyExpr(expr)
      result += [")"]
      return result
    case let .NatRec(expr1, expr2, expr3):
      var result = [String]()
      result += ["Nat::rec"]
      result += ["("]
      result += prettifyExpr(expr1)
      result += [","]
      result += prettifyExpr(expr2)
      result += [","]
      result += prettifyExpr(expr3)
      result += [")"]
      return result
    case let .Fold(type_, expr):
      var result = [String]()
      result += ["fold"]
      result += ["["]
      result += prettifyType(type_)
      result += ["]"]
      result += prettifyExpr(expr)
      return result
    case let .Unfold(type_, expr):
      var result = [String]()
      result += ["unfold"]
      result += ["["]
      result += prettifyType(type_)
      result += ["]"]
      result += prettifyExpr(expr)
      return result
    case .ConstTrue:
      var result = [String]()
      result += ["true"]
      return result
    case .ConstFalse:
      var result = [String]()
      result += ["false"]
      return result
    case .ConstUnit:
      var result = [String]()
      result += ["unit"]
      return result
    case let .ConstInt(integer):
      var result = [String]()
      result += [integer.printed]
      return result
    case let .ConstDouble(double):
      var result = [String]()
      result += [double.printed]
      return result
    case let .ConstMemory(memoryaddress):
      var result = [String]()
      result += [memoryaddress.printed]
      return result
    case let .Var(stellaident):
      var result = [String]()
      result += [stellaident.printed]
      return result
  }
}

func prettifyListOfExpr(_ list: [Expr]) -> [String] {
  list.flatMap { item in prettifyExpr(item) + [","] }.dropLast()
}

func prettifyPatternBinding(_ node: PatternBinding) -> [String] {
  switch node {
    case let .APatternBinding(pattern, expr):
      var result = [String]()
      result += prettifyPattern(pattern)
      result += ["="]
      result += prettifyExpr(expr)
      return result
  }
}

func prettifyListOfPatternBinding(_ list: [PatternBinding]) -> [String] {
  list.flatMap { item in prettifyPatternBinding(item) + [","] }.dropLast()
}

func prettifyListOfExpr2(_ list: [Expr]) -> [String] {
  list.flatMap { item in prettifyExpr(item) + [";"] }
}

func prettifyType(_ node: Type_) -> [String] {
  switch node {
    case let .TypeFun(listtype, type_):
      var result = [String]()
      result += ["fn"]
      result += ["("]
      result += prettifyListOfType(listtype)
      result += [")"]
      result += ["->"]
      result += prettifyType(type_)
      return result
    case let .TypeForAll(liststellaident, type_):
      var result = [String]()
      result += ["forall"]
      result += prettifyListOfStellaIdent(liststellaident)
      result += ["."]
      result += prettifyType(type_)
      return result
    case let .TypeRec(stellaident, type_):
      var result = [String]()
      result += ["µ"]
      result += [stellaident.printed]
      result += ["."]
      result += prettifyType(type_)
      return result
    case let .TypeSum(type1, type2):
      var result = [String]()
      result += prettifyType(type1)
      result += ["+"]
      result += prettifyType(type2)
      return result
    case let .TypeTuple(listtype):
      var result = [String]()
      result += ["{"]
      result += prettifyListOfType(listtype)
      result += ["}"]
      return result
    case let .TypeRecord(listrecordfieldtype):
      var result = [String]()
      result += ["{"]
      result += prettifyListOfRecordFieldType(listrecordfieldtype)
      result += ["}"]
      return result
    case let .TypeVariant(listvariantfieldtype):
      var result = [String]()
      result += ["<|"]
      result += prettifyListOfVariantFieldType(listvariantfieldtype)
      result += ["|>"]
      return result
    case let .TypeList(type_):
      var result = [String]()
      result += ["["]
      result += prettifyType(type_)
      result += ["]"]
      return result
    case .TypeBool:
      var result = [String]()
      result += ["Bool"]
      return result
    case .TypeNat:
      var result = [String]()
      result += ["Nat"]
      return result
    case .TypeUnit:
      var result = [String]()
      result += ["Unit"]
      return result
    case .TypeTop:
      var result = [String]()
      result += ["Top"]
      return result
    case .TypeBottom:
      var result = [String]()
      result += ["Bot"]
      return result
    case let .TypeRef(type_):
      var result = [String]()
      result += ["&"]
      result += prettifyType(type_)
      return result
    case let .TypeVar(stellaident):
      var result = [String]()
      result += [stellaident.printed]
      return result
  }
}

func prettifyListOfType(_ list: [Type_]) -> [String] {
  list.flatMap { item in prettifyType(item) + [","] }.dropLast()
}

func prettifyVariantFieldType(_ node: VariantFieldType) -> [String] {
  switch node {
    case let .AVariantFieldType(stellaident, optionaltyping):
      var result = [String]()
      result += [stellaident.printed]
      result += prettifyOptionalTyping(optionaltyping)
      return result
  }
}

func prettifyListOfVariantFieldType(_ list: [VariantFieldType]) -> [String] {
  list.flatMap { item in prettifyVariantFieldType(item) + [","] }.dropLast()
}

func prettifyRecordFieldType(_ node: RecordFieldType) -> [String] {
  switch node {
    case let .ARecordFieldType(stellaident, type_):
      var result = [String]()
      result += [stellaident.printed]
      result += [":"]
      result += prettifyType(type_)
      return result
  }
}

func prettifyListOfRecordFieldType(_ list: [RecordFieldType]) -> [String] {
  list.flatMap { item in prettifyRecordFieldType(item) + [","] }.dropLast()
}

func prettifyTyping(_ node: Typing) -> [String] {
  switch node {
    case let .ATyping(expr, type_):
      var result = [String]()
      result += prettifyExpr(expr)
      result += [":"]
      result += prettifyType(type_)
      return result
  }
}
